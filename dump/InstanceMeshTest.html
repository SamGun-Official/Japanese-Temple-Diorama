<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="three.js"></script>
    <script src="./node_modules/three/examples/js/loaders/GLTFLoader.js"></script>
    <script src="./node_modules\three\examples\js\controls\OrbitControls.js"></script>
    <script src="./node_modules\three\examples\js\controls\FirstPersonControls.js"></script>
</head>
<body>
    
</body>

<script>
    // scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color( 0x333333 );

    // camera
    const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
    camera.position.set( 5, 5, 0 );
    camera.lookAt( 0, 0, 0 );

    // renderer
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    // light
    const light = new THREE.PointLight( 0xffffff, 5, 50 );
    light.position.set( 5, 5, 0 );
    scene.add( light );

    const controls = new THREE.OrbitControls(camera, renderer.domElement)
    // const controls = new THREE.FirstPersonControls(camera, renderer.domElement)
    // controls.movementSpeed = 50;

    // loader
    const loader = new THREE.GLTFLoader();
    
    var object; 
    
    // 3D obj for matrix calc
    var dummy = new THREE.Object3D();

    // Instance mesh
    var mesh;

    // buffer geometry for object
    var glTFGeometry = new THREE.BufferGeometry();

    // on resize
    window.addEventListener( 'resize', onWindowResize );

    loader.load(
        "./rock_scan_-_13/scene.gltf",
        // model loaded
        function(gltf){

            gltf.animations; // Array<THREE.AnimationClip>
            object = gltf.scene; // THREE.Group
            gltf.scenes; // Array<THREE.Group>
            gltf.cameras; // Array<THREE.Camera>
            gltf.asset; // Object

            let material = new THREE.MeshNormalMaterial();

            gltf.scene.traverse( function ( child ) {
                if ( child.isMesh ) {
                    // child.material.envMap = envMap;

                    //Setting the buffer geometry
                    glTFGeometry = child.geometry.clone();
                    material = child.material.clone();
                }
            } );

            glTFGeometry.computeVertexNormals();
            glTFGeometry.scale( 4, 4, 4 );
            


            mesh = new THREE.InstancedMesh(glTFGeometry,material,1000);
            mesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage );
            scene.add(mesh);

            animate();
        },

        // model loading
        function(xhr){
            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
        },
        // called when loading has errors
        function ( error ) {
            console.log( 'An error happened' );
        }
    );

    function animate() {
        requestAnimationFrame( animate );

        // let time = clock.getDelta();
        const time = Date.now() * 0.001;
        if (mesh){
            
            mesh.rotation.x = Math.sin(time/4);
            mesh.rotation.y = Math.sin(time/2);

            let amount = 10;

            let i = 0;
            const offset = ( amount - 1 ) / 2;

            for ( let x = 0; x < amount; x ++ ) {

                for ( let y = 0; y < amount; y ++ ) {

                    for ( let z = 0; z < amount; z ++ ) {

                        dummy.position.set( offset - x, offset - y, offset - z );
                        dummy.rotation.y = ( Math.sin( x / 4 + time ) + Math.sin( y / 4 + time ) + Math.sin( z / 4 + time ) );
                        dummy.rotation.z = dummy.rotation.y * 2;

                        dummy.updateMatrix();

                        mesh.setMatrixAt( i ++, dummy.matrix );

                    }

                }

            }
            mesh.instanceMatrix.needsUpdate = true;
        }

        // mixer.update(clock.getDelta() * mixer.timeScale);

        // controls.update(clock.getDelta())

        renderer.render( scene, camera );
    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

</script>
</html>